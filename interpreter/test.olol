
def x = 3;
fun f y = x + y;
f : 2;  //=^.^= powinno byc 5

120 - 300;    //=^.^= powinno byc -180

/=^.^="
   tam wyzej powinno byc 5
=^.^=/



fun elo a b c = if c && true then a else b;

elo : 2 : 3 : true; //=^.^= powinno byc 2
elo : 2 : 3 : false;  //=^.^= powinno byc 3



//=^.^=  fun aDawajSprawdzRekurencje n = if n == 1 then 1 else n * aDawajSprawdzRekurencje : n - 1;  -?> nieskonczona petla ma sens
fun aDawajSprawdzRekurencje n = if n == 1 then 1 else n * aDawajSprawdzRekurencje : (n - 1);
aDawajSprawdzRekurencje : 5;  //=^.^= powinno byc 120



(\x y -> x + y * 2) : 2 : 3;  //=^.^= powinno byc 8
\x y -> x + y * 2; //=^.^= Given function od argument x



//=^.^= Comparation operators
2 == 2;  //=^.^= True
2 != 2;  //=^.^= False




/=^.^=




2 == true; //=^.^= error type


def a = 1;


7 : 7;

//=^.^= Higher order functions
fun f_add x y = x + y;
fun callAdd fadd x y = fadd : x : y;
callAdd : f_add : 2 : 3; //=^.^= 5




(\x y -> x + y * 2) : p : 3;  //=^.^= invalid identifier p  -> ok
(\x y -> x + y * p) : 2 : 3;  //=^.^= type zly  ->  a chcemy invalid identifier :( -> jak wywale ta rekurencje to jest ok




//=^.^= Static binding (if the binding was dynamic the output would be 10)
def krowa = 3;
fun myszka pies = pies + krowa;
(\krowa -> (myszka : krowa)) : 5;    //=^.^= powinno być 8




//=^.^= if errors
if true then 2 else false; //=^.^= error e1 not match e2 NIEEEEEEEE, bo leniwie
if 2 then 2 else false; //=^.^= error b not boolean
if (\x y -> x + y * 2) then 2 else false; //=^.^= error b not boolean
if ((\x -> x) : true) then 22 else 33; //=^.^= powinno byc 22
if ((\x y -> x > y) : 2 : 3) then 22 else 33; //=^.^= powinno byc 33




//=^.^= if with functions
fun f1 x = x;
fun f2 x = 2 * x;
(if 1 == 1 then f1 else f2) : 5;   //=^.^= ok -> 5
(if false then f1 else f2) : 5;   //=^.^= ok -> 10




//=^.^= def ola = fun pi pii = pii;  -> parse error reserved syntax
pi : 2;  
(if c then 1 else 2) : true;   //=^.^= invalid identifier c



def koko = 4 / 0;
if true then koko else 4;    //=^.^=  chcemy błąd



  def i fun

def k s = k + 2;    -> nie sparsuje sie
uzycie fun, jak defa i cokolwiek jest ok  -> <3
def dla list ???????? -> czy bedzie dzialac
def = lambda jest u nas ok <3





//=^.^=  Lists
def lo = [3, 1, 2];

lo == 2;     //=^.^=  zły type





=^.^=/


head [1, 1, 2];   //=^.^=  1
empty;

fun list_fun = [3, 1, 2];
list_fun;
head [[2, 3], 1, 2];   //=^.^=  [2, 3]
tail [[2, 3], 1, 2];
head [1 + 3 * 4, 1, 2];  //=^.^=  12
head [if true then 2 else 4, 5, 7, 8];    //=^.^=  2
tail [if true then 2 else 4, 12, if false then 2 else 4, 8];    //=^.^=  [12, 4, 8]


fun lii x = x;
lii : [1, 2, 4, 5];

if (head [true, false]) then 23 else 48; //=^.^=  23



//=^.^=  def dla listy
def l = [1, 2, 3, 4];
fun helo l = l;
helo : l;
tail l;


//=^.^=  parsing empty
def pipis = [];
helo : pipis;


//=^.^=  lista zmiennych
def łoś = 15 * 2;
def mućka = \x -> x + 2;
fun alpaczka b = if b then 44 else 66;
def lista_ze_zmiennymi = [łoś, mućka, alpaczka];
def lista_ze_zmiennymi2 = [alpaczka, mućka, alpaczka];
def lista_ze_zmiennymi3 = [mućka, mućka, alpaczka];


head lista_ze_zmiennymi;
head lista_ze_zmiennymi2;
(head lista_ze_zmiennymi2) : true;    //=^.^=  44


head lista_ze_zmiennymi3;
//=^.^=   tail lista_ze_zmiennymi3;                                          NIE DZIAŁA!!!!!!!!!!


//=^.^=  head i tail na zmiennej
head l;



//=^.^=   zagnieżdżony head tail
head (tail lista_ze_zmiennymi3);


//=^.^=   zagnieżdżone listy
def haha = [[1, 2], [if true then 4 else 5], [1, [[true, true], false]]];
tail haha;

def nested = [[[[111, 2], 3], 4], 5];
head (head (head (head nested)));



head pipis; //=^.^=  błąd: head na pustej liście



fun list_wrong = [true == false, 1, 2];
list_wrong;   //=^.^=  błąd wewnątrz ewaluacji listy


head (1 + 2);
head (empty);




/=^.^=

   head, tail dla pustej listy, head empty na zmiennej
   listy zmiennych
   head i tail od funkcji i od empty.
   head i tail od siebie samych;
   head, tail dla pustych
concat !!!!
TAIL OD NIEARGUMENTOWANYCH FUNKCJI NIE DZIALA
=^.^=/